{"version":3,"sources":["../src/utils.ts","../src/errors.ts","../src/consts.ts","../src/flexstate.ts"],"names":["StateMachineError","Error","NotRunningError","InvalidStateError","FinalStateError","TransitionError","TransitioningError","CancelledTransitionError","ResumeTransitionError","SideEffectTransitionError","IDLE_STATE","name","value","next","ERROR_STATE","final","Number","MAX_SAFE_INTEGER","undefined","title","initial","enter","done","leave","resume","timeout","timeoutWrapper","FlexEvent","delay","getClassStaticValue","isPlainObject","getDecorators","FlexStateEvents","START","STOP","FINAL","ERROR","FlexStateTransitionEvents","BEGIN","END","CANCEL","CANCEL_TRANSITION","EnterStateEvent","LeaveStateEvent","DoneStateEvent","ResumeStateEvent","FlexStateMachine","constructor","options","Object","assign","parent","context","autoStart","states","actions","injectActionMethod","throwActionError","injectStateValue","history","_addStates","_addTransitionListeners","_registerActions","_addParentStateListener","start","scope","running","CURRENT","current","transitioning","on","_stop","addedState","initialState","keys","state","_emitStateMachineEvent","e","stop","eventMap","normaizedState","finalState","stateAliasName","hookEvents","stateName","toLowerCase","methodName","event","_makeStateHookCallback","firstUpperCaseStateAliasName","firstUpperCaseStateName","off","resultState","findIndex","s","offAll","staticActions","decoratedActions","_getDecoratoredActions","action","entries","flexStringArrayArgument","pending","when","endStates","forEach","param","Array","fromStates","nextStates","getState","isArray","args","whenState","oldStateName","_transitionToError","_normalizeAction","TypeError","useExternalContext","conflictMethods","setTimeout","resolve","execute","actionName","emit","currentState","_emitStateHookCallback","nextState","isDone","beginTime","now","transitionInfo","from","canTransitionTo","_safeEmitEvent","leaveResult","error","enterResult","resumeResult","_addHistory","eventResults","errorIndex","returnValue","fromState","toState","arguments","some","fn","runOptions","wrapperFn","callCount","retryInterval","hasError","ms","retryCount","result","cancel","_assertRunning","forState","waitForState"],"mappings":"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","sourcesContent":["/**\r\n *   工具函数\r\n \r\n */\r\n\r\n\r\nimport \"reflect-metadata\";\r\n \r\n/**\r\n * \r\n * 处理字符串参数\r\n * \r\n * 该参数可以是一个字符串或者返回字符串的函数\r\n * \r\n * 当参数是一个函数时执行该函数的结果\r\n * \r\n * flexStringArgument(\"a\")   == \"a\"\r\n * flexStringArgument(()=>\"a\")   == \"a\"\r\n * flexStringArgument(()=>\"a\",context)   == \"a\"  为函数传入this\r\n * flexStringArgument((a,b)=>`${a}a${b}`,context,1,2)   == \"1a2\"  为函数传入this和参数 \r\n * \r\n * @param {*} param \r\n */\r\n export function flexStringArgument(param:any,...args:any[]){\r\n    let result = param\r\n    if(typeof(param)===\"function\"){\r\n        result= param.call(...args) \r\n    }\r\n    if(typeof(result)!=\"string\"){\r\n        return result ? String(result) : result\r\n    }\r\n    return result\r\n}\r\n\r\n /*  \r\n*    通用字符串数组参数，当需要接收一个字符串数组作为参数时使用\r\n\r\n*   flexStringArray支持更加灵活的参数定义。\r\n*  - 当param是一个函数，则会自动执行其返回值\r\n*  - 当param不是数组时，会扩展为数组\r\n*  - 当param是字符串时，使用,进行拆分为数组\r\n* \r\n* flexStringArrayArgument(\"xxx\")  ==  [\"xxx\"]\r\n* flexStringArrayArgument()  ==  []\r\n* flexStringArrayArgument([\"a\",\"b\"])  ==  [\"a\",\"b\"]\r\n\r\n  当param是一个函数时\r\n  fn= ()=>\"x\"\r\n* flexStringArrayArgument(fn)  ==  [\"x\"]\r\n  // 可以为函数传入this及参数\r\n  flexStringArrayArgument(fn,this,1)  == fn.call(this,1)=== [\"x\"]  \r\n\r\n* flexStringArrayArgument([\"a\",()=>\"x\"])  ==  [\"a\",\"x\"]\r\n\r\n  // 如果是一个使用,分割的字符串，则自动转成字符串\r\n* flexStringArrayArgument(\"a,b\") == [\"a\",\"b\"]\r\n* \r\n* @param {*} param \r\n*/\r\nexport function flexStringArrayArgument(param:any,...args:any[]){\r\n    let results = typeof(param)===\"function\"  ? param.call(...args)  : param\r\n    results = Array.isArray(results) ? results : (results ? (typeof(results)===\"string\" ? results.split(\",\") : [results]) : [] ) \r\n    return results.map((result:any)=>typeof(result)===\"function\" ? result.call(...args) : (typeof(result)==\"string\" ? result :String(result)))\r\n}\r\n\r\n/**\r\n * 处理对象参数\r\n * 1. 当参数是函数时执行并返回结果值\r\n * 2. 当param不是Object时，如果指定个默认参数，由视\r\n * \r\n * flexObjectArgument(1,{value:100,count:1},\"value\")  == {value:100,count:1}\r\n * flexObjectArgument({x:1,y:1},{value:100,count:1})  == {x:100,y:1,value:100,count:1}\r\n * \r\n * \r\n * @param {*} param \r\n * @param  {...any} args \r\n */\r\n// export function flexObjectArgument(param:any,defaultValue:Object={},defaultKey:string){    \r\n//     let results:{[ prop:string]:any } = {},params  = param \r\n//     if(typeof(params)===\"function\") params = params.call() \r\n//     if(typeof(params)===\"object\"){\r\n//         if(defaultKey) results[defaultKey]= params\r\n//     }else{\r\n//         results = params\r\n//     }     \r\n//     return Object.assign({},defaultValue,results)\r\n// }\r\n\r\n ","// 错误\r\nexport class StateMachineError extends Error {}\r\nexport class NotRunningError extends StateMachineError{}\r\nexport class InvalidStateError extends StateMachineError { } \r\nexport class FinalStateError extends StateMachineError { } \r\nexport class TransitionError extends StateMachineError { }          \r\nexport class TransitioningError extends TransitionError { }        \r\nexport class CancelledTransitionError extends TransitionError { }\r\nexport class ResumeTransitionError extends TransitionError { }          \r\nexport class SideEffectTransitionError extends TransitionError{}\r\n","import type { IDLE_STATE_TYPE,ERROR_STATE_TYPE} from \"./flexstate\"\r\n\r\n// 状态机未初始化时的特殊状态值\r\nexport const IDLE_STATE: IDLE_STATE_TYPE = { name: 'IDLE', value: null, next: \"*\" }\r\n// 出错状态\r\nexport const ERROR_STATE:ERROR_STATE_TYPE = { name: \"ERROR\", final: true, value: Number.MAX_SAFE_INTEGER, next: \"*\"}\r\n\r\n/**\r\n * 默认状态值\r\n */\r\nexport const DefaultStateParams = {\r\n    name   : \"\",                                    // 状态名称\r\n    alias  : undefined,                             // 状态别名 \r\n    value  : 0,                                     // 状态值，一般是数值>,\r\n    title  : \"\",                                    // 状态标题，一般用于显示\r\n    initial: false,                                 // 是否是初始化状态 \r\n    final  : false,                                 // 最终状态\r\n    next   : [],                                    // 定义该状态的下一个状态只能是哪些状态\r\n    enter  : undefined,\r\n    done   : undefined,\r\n    leave  : undefined,\r\n    resume : undefined\r\n}\r\n","import \"reflect-metadata\";\r\nimport {timeout as timeoutWrapper,FlexEvent,FlexEventOptions} from \"flex-tools\"\r\nimport {  flexStringArrayArgument, flexStringArgument} from \"./utils\"\r\nimport { delay, getClassStaticValue,  isPlainObject} from \"flex-tools\"\r\nimport { \r\n    StateMachineError,\r\n    NotRunningError,\r\n    InvalidStateError,\r\n    FinalStateError,\r\n    TransitionError,\r\n    TransitioningError,\r\n    CancelledTransitionError,\r\n    ResumeTransitionError,\r\n    SideEffectTransitionError\r\n} from \"./errors\" \r\nimport { getDecorators } from \"flex-decorators\";\r\nimport { DefaultStateParams, ERROR_STATE, IDLE_STATE } from \"./consts\";\r\n\r\n\r\n\r\nexport type FlexStateActionCallback = 'pending' | 'resolved' | 'rejected' | 'finally' \r\n\r\n/**\r\n *\r\n * 状态动作\r\n*/\r\nexport interface FlexStateAction{\r\n    name?         :string,                                      //指定唯一的动作名称\r\n    alias?        : string,  \t\t\t\t\t\t\t\t\t// 动作别名，当在实例中注入同名的方法时，如果指定别名，则使用该别名\r\n    injectMethod? : boolean,                                    // 是否上下文对象中注入同名的方法\r\n    // 指定该动作仅在当前状态是when中的一个时才允许执行动作\r\n    when?         : string | Array<string> | ((params:Object,current:FlexState)=>Array<string>),       \t\t                \r\n    pending?      : string | Function,                \t\t\t// 开始执行动作前切换到pending状态\r\n    resolved?     : string | Function,                \t\t\t// 执行成功后切换到resolved状态\r\n    rejected?     : string | Function,                \t\t\t// 执行失败后切换到rejected状态\r\n    finally?      : string | ((params:Object)=>Array<string>)   // 无论执行成功或失败均切换到finally状态\r\n    execute(...args:any[]):void                                 // 动作执行函数，具体干活的\r\n    [key:string]:any\r\n} \r\n\r\n// 动作列表{[name]:<FlexState>}\r\nexport type FlexStateActionMap= Record<string,FlexStateAction>\r\n\r\n/**\r\n * 状态动作装饰器参数\r\n */\r\nexport type FlexStateActionDecoratorOptions = Omit<FlexStateAction,\"name\" | \"execute\">\r\n\r\n// 状态转换监视事件参数\r\nexport interface FlexStateTransitionEventArguments{\r\n    event? : 'CANCEL' | 'BEGIN' | 'END' | 'ERROR'\r\n    from  : string\r\n    to    : string\r\n    error?: Error \r\n    params?:any\r\n    [key: string]:any\r\n}\r\n\r\n// 钩子参数 {from,to,error,params,retry,retryCount}\r\nexport type FlexStateTransitionHookArguments = Exclude<FlexStateTransitionEventArguments,'event'> & {\r\n    retryCount    : number                                                  // 重试次数,\r\n    retry         : Function | ((interval?:number)=>void)                   // 马上执行重试\r\n}\r\n\r\n\r\n/**\r\n * 状态转换钩子函数签名\r\n */\r\nexport type FlexStateTransitionHook = ((args:FlexStateTransitionHookArguments)=>Awaited<Promise<any>> | void ) | undefined  \r\n\r\nexport type FlexStateTransitionHookExt = FlexStateTransitionHook | [FlexStateTransitionHook,{timeout:number}]\r\n\r\nexport type FlexStateNext = string | Array<string> | (()=> Array<string> ) \r\n\r\nexport interface NewFlexState{\r\n    name?   : string,                                               // 状态名称,一般为英文\r\n    value   : number | null,                                        // <必须，状态值，Number类型>,\r\n    alias?  : string | undefined,                                   // 可选，状态别名                                 \r\n    title?  : string,                                               //<状态标题，一般用于显示> \r\n    initial?: boolean,                                              // <true/false,是否是初始化状态,只能有一个状态为初始状态>, \r\n    final?  : boolean,                                              // <true/false,最终状态>,                                                     \r\n    enter?  : FlexStateTransitionHookExt,                           // 当进入该状态时的钩子\r\n    leave?  : FlexStateTransitionHookExt,                           // 当离开该状态时的钩子\r\n    done?   : FlexStateTransitionHookExt,\t\t\t                // 当已切换至状态后\r\n    resume? : FlexStateTransitionHookExt,                           // 当离开后再次恢复时调用\r\n    next?   : FlexStateNext                                         // 定义该状态的下一个状态只能是哪些状态,也可以是返回下一个状态列表的函数,*代表可以转换到任意状态\r\n    [key    : string]:any                                           // 额外的参数\r\n}\r\n/**\r\n * 状态声明\r\n */\r\nexport type FlexState = Required<NewFlexState> \r\n\r\n// 状态参数，用来传状态参数时允许只传递状态名称或{}\r\nexport type FlexStateArgs = string | number | FlexState   \r\n\r\nexport type FlexStateMap = Record<string,NewFlexState> \r\n\r\nexport type IDLE_STATE_TYPE = Pick<FlexState,'name' | 'value' | 'next' >\r\nexport type ERROR_STATE_TYPE = Pick<FlexState,'name' | 'value' | 'next' | 'final' >\r\n\r\n\r\n  \r\n/**\r\n * 状态机事件\r\n */\r\nexport enum FlexStateEvents {\r\n    START = \"start\",\r\n    STOP  = \"stop\",\r\n    FINAL = \"final\",                         // 当状态机进入FINAL\r\n    ERROR = \"error\"                          // 发生状态机运行错误时\r\n}\r\n\r\n\r\n\r\n// 转换事件\r\nexport enum FlexStateTransitionEvents{\r\n    BEGIN  = \"transition/begin\",                     // 开始转换前\r\n    END    = \"transition/end\",                       // 转换结束后\r\n    CANCEL = \"transition/cancel\",                    // 转换被取消：不允许转换时\r\n    ERROR  = \"transition/error\",                     // 转换出错，主要状态回调事件执行出错\r\n    FINAL  = \"transition/final\",                     // 转换到最终状态时\r\n}\r\n\r\n\r\n// 取消正在进行的转换,当发出此指令时，会让状态转换回调中止\r\nconst CANCEL_TRANSITION = \"cancelTransition\"        \r\nconst RESET_STATE_MACHINE = \"resetStateMachine\"        \r\n\r\nconst EnterStateEvent  = (name: string) => `${name}/enter`\r\nconst LeaveStateEvent  = (name: string) => `${name}/leave`\r\nconst DoneStateEvent   = (name: string) => `${name}/done`\r\nconst ResumeStateEvent = (name: string) => `${name}/resume`\r\n\r\n/**\r\n * 状态机转换钩子回调\r\n */\r\nexport interface FlexStateTransitionHooks{\r\n    onTransition?(params:FlexStateTransitionEventArguments):void;    \r\n    onTransition?(params:FlexStateTransitionEventArguments):Awaited<Promise<any>>;\r\n    onTransitionBegin?(params:FlexStateTransitionEventArguments):Awaited<Promise<any>>;\r\n    onTransitionEnd?(params:FlexStateTransitionEventArguments):Awaited<Promise<any>>;\r\n    onTransitionError?(params:FlexStateTransitionEventArguments):Awaited<Promise<any>>;\r\n    onTransitionCancel?(params:FlexStateTransitionEventArguments):Awaited<Promise<any>>;\r\n}\r\n\r\nexport type TransitionHookTypes = keyof FlexStateTransitionHooks\r\n\r\nexport interface FlexStateMachineContext extends FlexStateTransitionHooks{    \r\n    [key: string]:any\r\n}\r\n\r\n\r\n/**\r\n * 状态机构造参数\r\n */\r\nexport interface FlexStateOptions extends FlexStateTransitionHooks,FlexEventOptions{\r\n    name?               : string,                                     // 当前状态机名称\r\n    states?             : FlexStateMap,                           // 状态声明\r\n    parent?            : FlexState,                                  // 父状态实例\r\n    context?           : any,                                        // 当执行动作或状态转换事件时的this指向\r\n    autoStart?         : boolean,                                    // 是否自动开始运行状态机，=false需要调用.start()\r\n    actions?           : FlexStateActionMap,                         // 动作声明\r\n    injectActionMethod?: boolean,                                    // 将动作方法注入到当前实例中\r\n    throwActionError?  : boolean,                                    // 是否在执行动作方法时抛出错误\r\n    injectStateValue?  : boolean,                                    // 在实例中注入：大写状态名称的字段，其值 =状态值\r\n    history?           : number                                      // 记录状态转换历史，0=不记录，N=最大记录N条历史\r\n    scope?             : FlexStateMachine,                           // 内部独立子状态域\r\n}  \r\n\r\n\r\n\r\n \r\nexport class FlexStateMachine extends FlexEvent{  \r\n    static states : FlexStateMap = {  }\r\n    static actions: FlexStateActionMap = {}\r\n    states        : Record<string, FlexState>= {}\r\n    #initialState : FlexState = IDLE_STATE as  FlexState                   // 初始状态\r\n    #finalStates  : Array<string> = []                                     // 保存最终状态名称\r\n    #currentState : FlexState = IDLE_STATE  as  FlexState                  // 当前状态\r\n    #transitioning: boolean = false                                        // 是否正在转换中\r\n    #running      : boolean = false                                        // 是否处于运行状态\r\n    #name         : string  = ''                                                // 状态机名称\r\n    #history      : Array<[number,string]> = []                            // 状态转换历史=[[时间戳,状态名称],[时间戳,状态名称]]\r\n    #actions      : {[name:string]:Function} = {}                          // 保存经过封装的动作\r\n    #conflictMethods:Record<string,any> = {};\r\n    [key:string]:any\r\n    constructor(options : FlexStateOptions={}) {\r\n        super(Object.assign({\r\n            name              : \"\",                                         // 当前状态机名称\r\n            parent            : null,                                       // 父状态\r\n            context           : null,                                       // 当执行动作或状态转换事件时的this指向\r\n            autoStart         : true,                                       // 是否自动开始运行状态机，=false需要调用.start()\r\n            states            : {},                                         // 状态声明\r\n            actions           : {},                                         // 动作声明\r\n            injectActionMethod: true,                                       // 将动作方法注入到当前实例中\r\n            throwActionError  : false,                                      // 是否在执行动作方法时抛出错误\r\n            injectStateValue  : true,                                       // 在实例中注入：大写状态名称的字段，其值 =状态值\r\n            history           : 0                                           // 记录状态转换历史，0=不记录，N=最大记录N条历史\r\n        }, options)) \r\n        if(!this.options.context) this.options.context = this             //  \r\n        this.#name = this.options.name || this.constructor.name\r\n        this._addStates()                                                   // 所有状态声明\r\n        this._addTransitionListeners()                                      // 扫描配置里面定义的所有状态侦听器\r\n        this._registerActions()                                             // 注册动作\r\n        this._addParentStateListener()                                      // 侦听父状态的进入与离开\r\n        if(this.options.autoStart) this.start()                            // 自动开始切换\r\n    }         \r\n\r\n    /**************************** 公开属性 *****************************/\r\n    get name(): string {return this.#name}    \r\n    get context() { return this.options.context || this }                          // 状态机上下文实例\r\n    get parent() { return this.options.parent }                            // 父状态\r\n    get scope() { return this.options.scope }                              // 父状态所在的状态机实例\r\n    get running() { return this.#running }                                  // 当前作用域  \r\n    get actions() { return this.#actions }                                  // 已注册的动作列表={<name>:{....}}\r\n    get CURRENT() { return this.current.value }                             // 当前状态值  \r\n    get current() { return this.#currentState }                             // 当前状态，返回{name,value,....}\r\n    get initial() { return this.#initialState }                             // 返回初始状态\r\n    get transitioning() { return this.#transitioning }                      // 正在转换状态标志\r\n    get history() { return this.#history }                                  // 返回状态历史\r\n    get options():Required<FlexStateOptions> & FlexEventOptions{\r\n        return super.options as Required<FlexStateOptions> & FlexEventOptions\r\n    }                                    \r\n    /**************************** 初始化 *****************************/\r\n    private _addParentStateListener(){\r\n        if(this.parent){\r\n            // 当进入该父状态时启动子状态机\r\n            this.parent.on(\"done\",async ()=> await this.start())\r\n            // 当要离开父状态时停止子状态机\r\n            this.parent.on(\"leave\",async ()=>await this._stop())  \r\n            // 当父状态进入错误时也停止子状态机\r\n            this.scope?.on(`ERROR/done`,async ()=>await this._stop())              \r\n        }        \r\n    }\r\n    /**\r\n     * 状态可以以下定义\r\n     *  static states={...} <--- 构造参数\r\n     *  \r\n     * \r\n     * 规范化状态数据\r\n     * state={\r\n     *     name:\"<状态名称>\",\r\n     *     value:<状态值>,                                              \r\n     *     title:\"<状态标题，一般用于显示>\",            \r\n     *     enter:async ({previous,context,params})=>{},                     // 转换到此状态的回调\r\n     *     leave:async ({next,context})=>{},                                // 离开此状态时的回调\r\n     *     next:[\"\"]                                                        // 允许的下一个状态\r\n     * }\r\n     */\r\n    private _addStates():void {        \r\n        // 如果指定了父状态，则不读取context上面的states\r\n        const staticStates:{[key:string]:FlexState} = this.parent ? {} : getClassStaticValue(this.context, \"states\")\r\n        // static states <- this.options.states \r\n        const definedStates : {[key:string]:FlexState} = Object.assign({},staticStates, this.options.states)\r\n        if(Object.keys(definedStates).length==0) throw new StateMachineError(\"未提供状态机定义\")\r\n\r\n        for (let [name, state] of Object.entries(definedStates)) {\r\n            state.name = name\r\n            let addedState:FlexState = this._add(state);          \r\n            // 将状态值映射为实例的属性，可以直接以大写方式访问，如fsm.CONNECTED===state.value  \r\n            if(this.options.injectStateValue){\r\n                (this.context as any)[name.toUpperCase()] = addedState.value;       \r\n                (this as any)[name.toUpperCase()] = addedState.value;           \r\n    \r\n            }\r\n            if(addedState.initial) this.#initialState = addedState\r\n            if(addedState.final) this.#finalStates.push(addedState.name)\r\n        }                  \r\n        // 如果没有指定初始状态，则默认使用第一个状态作为初始状态\r\n        if (!this.isValid(this.#initialState)) {\r\n            this.#initialState = this.states[Object.keys(this.states)[0]]\r\n        }   \r\n        // 自动添加一个错误状态                \r\n        this.states[\"ERROR\"] = Object.assign({},ERROR_STATE) as FlexState;\r\n        if(this.options.injectStateValue) (this.context as any)[\"ERROR\"] = ERROR_STATE.value\r\n        // 自动添加一个IDLE状态\r\n        this.states[\"IDLE\"] = Object.assign({},IDLE_STATE) as FlexState;\r\n        if(this.options.injectStateValue) (this.context as any)[\"IDLE\"] = IDLE_STATE.value\r\n\r\n    } \r\n    /**************************** 状态机管理 *****************************/\r\n    /**\r\n     * 触发状态机事件\r\n     * @param {*} event \r\n     */\r\n    private _emitStateMachineEvent(event:string,...args:Array<any>):void {\r\n        try{\r\n            this.emit(event,...args)\r\n        }catch(e){}\r\n    }\r\n\r\n    /**\r\n     * 开始运行状态机\r\n     * 即转换到初始状态\r\n     * 如果当前状态不为空，则直接返回\r\n     */\r\n    async start() {\r\n        if(this.#running) return \r\n        this.#running = true        \r\n        this._emitStateMachineEvent(FlexStateEvents.START)\r\n        try{\r\n            return await this.transition(this.#initialState)\r\n        }catch(e){\r\n            this._stop(e)\r\n        }\r\n    }\r\n    private _stop(e?:any){\r\n        if(this.#transitioning) this.emit(CANCEL_TRANSITION)\r\n        this.#currentState = IDLE_STATE as FlexState\r\n        this.#running = false\r\n        this._emitStateMachineEvent(FlexStateEvents.STOP,e)\r\n    }\r\n    /**\r\n     * 停止状态机运行\r\n     */\r\n    async stop(){\r\n        this._assertRunning()\r\n        this._stop()\r\n    }  \r\n\r\n    /**\r\n     * 重置状态机\r\n     * \r\n     * 重置操作：\r\n     *  - 取消正在进行的状态切换事件回调\r\n     *  - 当前状态置为IDLE_STATE\r\n     * \r\n     */\r\n    async reset() {\r\n        await this.stop()\r\n        await this.start()\r\n    }\r\n   /**************************** 状态管理 *****************************/\r\n\r\n    /**\r\n     *   注册切换侦听器\r\n\r\n    *  - 在配置中传入\r\n     *  - 类中定义\r\n     * onTransitionBegin,onTransitionEnd,onTransitionCancel,onTransitionError回调\r\n     *  - \r\n     */\r\n    private _addTransitionListeners() {\r\n        // onTransitionBegin,onTransitionEnd,onTransitionCancel,onTransitionError\r\n        const context = this.context \r\n        const eventMap:Array<[string,TransitionHookTypes]> = [\r\n            [FlexStateTransitionEvents.BEGIN, \"onTransitionBegin\"],\r\n            [FlexStateTransitionEvents.END, \"onTransitionEnd\"],\r\n            [FlexStateTransitionEvents.CANCEL, \"onTransitionCancel\"],\r\n            [FlexStateTransitionEvents.ERROR, \"onTransitionError\"]\r\n        ]\r\n        // 定义在上下文实例中的回调\r\n        if(context){\r\n            eventMap.forEach(([event,method]) => {\r\n                if(typeof(context?.[method])===\"function\"){\r\n                    this.on(event,context[method].bind(context))\r\n                }\r\n            })     \r\n            // onTransition相当于所有事件总\r\n            if(typeof(context.onTransition)===\"function\"){\r\n                Object.values(FlexStateTransitionEvents).forEach(event=>this.on(event,context.onTransition!.bind(context)))\r\n            }       \r\n        }\r\n        // 定义在构造参数中的回调\r\n        eventMap.forEach(([event,method]) => { \r\n            if(typeof(this.options[method])===\"function\"){\r\n                this.on(event,this.options[method]!.bind(context))\r\n            }\r\n        }) \r\n        // onTransition相当于所有事件\r\n        if(typeof(this.options.onTransition)===\"function\"){\r\n            Object.values(FlexStateTransitionEvents).forEach(event=>this.on(event,this.options.onTransition!.bind(context)))\r\n        }     \r\n    }\r\n    /**\r\n     * 规范化状态数据\r\n     * @param {*} state \r\n     * @returns \r\n     */\r\n    private _normalizeState(state:FlexState):FlexState{\r\n        let normaizedState:FlexState = Object.assign({},DefaultStateParams,state)\r\n        if(!normaizedState.name) throw new StateMachineError(\"状态必须指定有效的名称\")\r\n        if(typeof(normaizedState.value)!=\"number\") throw new StateMachineError(\"状态必须指定有效的状态值\")\r\n\r\n        // state.next可以是字符串、状态名称数组、或者函数,统一转换为[状态名称,状态名称,状态名称]或者是一个函数(在需要时调用)\r\n        if (typeof (normaizedState.next) == \"string\") {\r\n            normaizedState.next = [normaizedState.next]\r\n        } else if (state.next === undefined) {\r\n            normaizedState.next = []\r\n        }else if(!Array.isArray(normaizedState.next) && typeof(normaizedState.next)!=\"function\"){\r\n            normaizedState.next = []\r\n        }   \r\n        if(typeof(normaizedState.next)!=\"function\") normaizedState.next.push(\"ERROR\")           // 任何状态均可以转换至错误状态\r\n        return normaizedState\r\n    }\r\n    /**\r\n     * 增加状态\r\n     * @param state \r\n     * @returns \r\n     */\r\n    private _add(state:FlexState):FlexState{\r\n        const context = this.context\r\n        let finalState:FlexState = this._normalizeState(state) \r\n        let stateName = finalState.name\r\n        let stateAliasName = finalState.alias\r\n\r\n        const hookEvents=[\"Enter\",\"Leave\",\"Done\",\"Resume\"]\r\n\r\n        // 1. 注册在定义在状态中的enter/leave/done/resume回调       \r\n        hookEvents.forEach(event=>{\r\n            let method = finalState[event.toLowerCase()]\r\n            if (typeof (method) == \"function\") {\r\n                this.on(`${stateName}/${event.toLowerCase()}`, this._makeStateHookCallback(method).bind(context))\r\n            }    \r\n        }) \r\n\r\n        // 2. 订阅类中定义on<State>Enter、on<State>Resume,<State>Leave、on<State>End的函数，则自动注册其状态回调\r\n        let firstUpperCaseStateName = `${stateName.slice(0,1).toUpperCase()}${stateName.substring(1).toLowerCase()}`\r\n        let firstUpperCaseStateAliasName = stateAliasName ? `${stateAliasName.slice(0,1).toUpperCase()}${stateAliasName.substring(1).toLowerCase()}` : undefined\r\n        hookEvents.forEach(event=>{\r\n            const methodName = `on${firstUpperCaseStateAliasName || firstUpperCaseStateName}${event}`\r\n            if (typeof(context[methodName]) === 'function'){\r\n                this.on(`${stateName}/${event.toLowerCase()}`, this._makeStateHookCallback(context[methodName]).bind(context))\r\n            }    \r\n        }) \r\n        // 3. 为on<State>Done提供一个别名on<State>\r\n        const methodName = `on${firstUpperCaseStateAliasName || firstUpperCaseStateName}`\r\n        if (typeof(context[methodName]) === 'function'){\r\n            this.on(`${stateName}/done`, this._makeStateHookCallback(context[methodName]).bind(context))\r\n        }\r\n\r\n        // 4. 为每一个状态生成一个 waitFor<State>异步等待方法，用来等待切换到该状态\r\n        (this as any)[`waitFor${firstUpperCaseStateName}`]=async () =>await this.waitForState(stateName)\r\n\r\n        // 5. 在状态机实例中注入一个大写的状态值字段，如Connected状态={value:1},则fsm.CONNECTED===1\r\n        if(this.options.injectStateValue){\r\n            this.context[stateName.toUpperCase()] == finalState.value\r\n        }\r\n\r\n        // 6. 为该状态提供一个创建子状态的方法\r\n        if(isPlainObject(finalState.scope) && Object.keys(finalState.scope).length>0){\r\n            this._createStateScope(finalState,finalState.scope)\r\n        }\r\n\r\n        finalState.createScope = (options:FlexStateOptions)=>this._createStateScope(finalState,options)\r\n\r\n        // 7. 允许通过states.connected.on(\"enter\",cb)形式订阅该状态的事件\r\n        finalState.on=(event:string,cb:FlexStateTransitionHook)=>this.on(`${stateName}/${event}`,cb as any)\r\n        finalState.off=(event:string,cb:FlexStateTransitionHook)=>this.off(`${stateName}/${event}`,cb as any) \r\n        \r\n\r\n        this.states[stateName] = finalState        \r\n        return this.states[stateName] \r\n    }\r\n\r\n\r\n    /**\r\n     * 为指定的状态创建一个子状态机\r\n     * @param {*} state \r\n     * @param {*} settings \r\n     * @returns \r\n     */ \r\n    private _createStateScope(state:FlexState,options:FlexStateOptions) {        \r\n        if(state.scope) throw new StateMachineError(\"子状态已经定义\")\r\n        // 创建子状态机\r\n        state.scope = new FlexStateMachine({\r\n            ...options, \r\n            scope : this,                           // 引用父状态机实例\r\n            parent   : state,                       // 父状态            \r\n            context  : this.context,\r\n            autoStart: false                        // 当<父状态/done>时，即转换到父状态后，启动子状态机\r\n        })       \r\n        return state.scope\r\n    }\r\n\r\n    /**\r\n     * 返回状态数据 \r\n     *    states={ready:{name:\"ready\",value:1,title:\"准备就绪\"}}\r\n     * \r\n     *    getState(1) == states.ready\r\n     *    getState(\"ready\") == states.ready\r\n     *    getState(()=>\"ready\")== states.ready\r\n     *    getState(()=>1)== states.ready\r\n     *    getState({name:\"ready\",...}) =  states.ready\r\n     * \r\n     * @param {*} param  状态名称 | 状态值 | 或返回状态名称或值的函数\r\n     * @param {*} args   当param是一个函数时用来额外传递给函数的参数\r\n     * @returns 状态   返回完整的数据{...}\r\n     */\r\n     getState(param: FlexStateArgs | Function | undefined,...args:Array<any>):FlexState {\r\n        let resultState  \r\n        resultState = typeof(param)===\"function\" ? (param as Function).call(this,...args) : param\r\n        if(typeof(resultState)===\"string\" && (resultState in this.states)){\r\n            return this.states[resultState]\r\n        }else if(typeof(resultState)===\"number\"){\r\n            for (let state of Object.values(this.states)) {\r\n                if (state.value === resultState) return state\r\n            }            \r\n        }else if(isPlainObject(resultState) && (resultState.name in this.states)){\r\n            return this.states[resultState.name]\r\n        }       \r\n        throw new InvalidStateError() \r\n    }\r\n    /**\r\n     * 增加状态\r\n     * add({\r\n     *      name:\"\",value:\"\",title: \"\",enter:()=>{},leave:()=>{},done:()=>{},next:[]\r\n     * })\r\n     * @param {*} state \r\n     */\r\n    add(state:NewFlexState){\r\n        let finalState = Object.assign({}, DefaultStateParams, state) as unknown as FlexState\r\n        if(!finalState.name || !finalState.value) throw new StateMachineError(\"状态必须指定有效的name和value参数\")\r\n        if((finalState.name in this.states) || Object.values(this.states).findIndex(s=>s.value===finalState.value)!=-1) throw new StateMachineError(`状态<{${finalState.name}}>已经存在`)\r\n        return this._add(finalState)\r\n    }\r\n    /**\r\n     * 移除状态\r\n     * @param {*} name \r\n     */\r\n    remove(name:string) {\r\n        if(name in this.states){    \r\n            this.offAll(`${name}/enter`)\r\n            this.offAll(`${name}/leave`)\r\n            this.offAll(`${name}/done`)\r\n            this.offAll(`${name}/resume`)            \r\n            delete this.states[name]\r\n        }\r\n    }\r\n    /**\r\n     * 返回指定的状态是否是有效的状态\r\n     * \r\n     * 状态必须定义在this.states中\r\n     * \r\n     * @param {*} state  状态名称 | 状态值 | FlexState\r\n     * @returns \r\n     */\r\n    isValid(state:any):boolean {\r\n        if(!state) return false\r\n        if(typeof(state)===\"string\"){\r\n            return state in this.states\r\n        }else if(typeof(state)===\"number\"){\r\n            return Object.values(this.states).some(s=>s.value===state)\r\n        }else if(isPlainObject(state)){\r\n            return Object.values(this.states).some(s=>(s.value===state.value) && (s.name===state.name))\r\n        }else{\r\n            return false\r\n        }        \r\n    }\r\n    /**\r\n     * \r\n     * 判断指定的状态是否与当前状态相匹配\r\n     * \r\n     * fsm.current.name === \"connect\"\r\n     * isCurrent(\"connect\") == true\r\n     * isCurrent({name:\"connect\",...}) == true\r\n     * action.pending=()=>{}\r\n     * isCurrent(action.pending) == true\r\n     * \r\n     * @param {*} state \r\n     * @returns \r\n     */\r\n    isCurrent(state:any):boolean {\r\n        if (typeof (state) == \"string\") {\r\n            return this.current.name === state\r\n        } else if (isPlainObject(state)) {\r\n            return state.name === this.current.name\r\n        }else if(typeof(state)===\"function\"){\r\n            return state() === this.current.name\r\n        }else{            \r\n            return false\r\n        }\r\n    }\r\n    /**\r\n     * 返回是否处理最终状态\r\n     */\r\n    isFinal(){\r\n       return this.current && this.current.final\r\n    }\r\n    \r\n    /**************************** 动作 *****************************/\r\n\r\n    /**\r\n     * 扫描当前context实例中所有被<@state>装饰的状态动作\r\n     * @returns \r\n     */\r\n    private _getDecoratoredActions(){       \r\n        // decoratedActions={method1:[{参数}]}  \r\n        let decoratedActions = getDecorators(this.context,\"flexState\") \r\n        Object.entries(decoratedActions).forEach(([methodName,[action]])=>{            \r\n            (action as FlexStateAction).execute = this.context[methodName]\r\n            decoratedActions[methodName] = action\r\n        })\r\n        return decoratedActions\r\n    }\r\n    /**\r\n     * 注册动作\r\n     * 扫描当前实例中所有被<@state>装饰的状态动作\r\n     * \r\n     * @state({\r\n     *   when         : [<>,<>],                //当前状态=when中的一个时才允许执行\r\n     *   alias        : \"<别名>\",               // 当指定时，将使用来在context生成一个方法，否则会使用动作名称\r\n     *   pending      : false,\r\n     *   execute      : async ()=>{...},\r\n     *   resolved     : \"<可选的,执行成功后的状态>\",\r\n     *   rejected     : \"<可选的,执行失败后的状态>\",\r\n     *   finally      : \"<可选的,无论执行成功或失败后均转至的状态>\",\r\n     *   timeout      : <超时>,\r\n     *   retryCount   : <重试次数>,\r\n     *   retryInterval: <重试间隔>\r\n     *   throttle     : <节流时间>\r\n     *   debounce     : <去抖动>\r\n     * })\r\n     * \r\n     *  \r\n     * 动作实质是要进入pending指定的状态，然后执行pending状态的enter方法\r\n     *  如果执行成功或失败，则切换到不同的状态\r\n     *  \r\n     * \r\n     *\r\n     */\r\n    private _registerActions() {\r\n        this.#actions = {}        \r\n        \r\n        // 如果是子状态则不进行\r\n        const staticActions:{[key:string]:FlexStateAction} = this.parent ? {} : getClassStaticValue(this.context, \"actions\")\r\n\r\n        // 获取装饰器装饰的动作函数       \r\n        // decoratedActions={method1:{参数}}\r\n        let decoratedActions = this._getDecoratoredActions()\r\n        // actions ={<动作名称>:{..动作参数...}}\r\n        let actions = Object.assign({},decoratedActions,this.options.actions) \r\n        for (let [name, action] of Object.entries(actions)) {\r\n            try{\r\n                if(Array.isArray(action)) action = action[0]\r\n                if(!(action as FlexStateAction).name) (action as FlexStateAction).name = name\r\n                this.register(action as FlexStateAction)\r\n            }catch(e:any){\r\n                console.error(\"注册异步状态机动作{}出错:{}\",[name,e.message])\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * \r\n     * 校验动作状态配置是否合理\r\n     * \r\n       当指定了when时, 需要检查action.pending/resolved/rejected/finally参数是否与state配置冲突\r\n          比如配置了when=\"Disconnected\",但是配置了pending=\"Diconnecting\",resolved=\"Disconnecting\"，这些均属于无效配置\r\n          应该对无效配置给出错误,但是由于when/pending/resolved/rejected/finally参数均支持函数\r\n         因此，只有当这些参数是字符串时才可以进行注册时检查\r\n        @param {*} action \r\n        @returns {Boolean} <true/false>\r\n     */\r\n    private _normalizeAction(action:FlexStateAction){\r\n        const name = action.name\r\n        // 1. 参数检查 \r\n        if (typeof (action.execute) != \"function\") {\r\n            throw new StateMachineError(`未定义状态动作函数${name}`)\r\n        }\r\n        if(name && (name in this.#actions)){\r\n            throw new StateMachineError(`状态机动作${name}已存在,不能重复注册`)\r\n        }  \r\n\r\n        // 判断参数配置是否有效： 必须是有效的状态名称字符串或者函数\r\n        [\"pending\",\"resolved\",\"rejected\",\"finally\"].forEach(param =>{\r\n            if(typeof(action[param]) == \"string\"){\r\n                if(action[param] && !this.isValid(action[param])){\r\n                    throw new StateMachineError(`动作参数${param}只能是有效的状态名称或者函数`)\r\n                }\r\n            }\r\n        })  \r\n        // when是一个数组[<状态>,<状态>,...]\r\n        action.when = flexStringArrayArgument(action.when,this.context,this.current)              \r\n        // 判断能否从when中其中一个状态切换到pending状态\r\n        // 仅当pending是一个字符串时生进行校验，如果是一个函数，则只能在动作执行时进行校验\r\n        if(typeof(action.pending)==\"string\" && Array.isArray(action.when) && action.when.length>0){ \r\n            // 如果pending在when中\r\n            if(action.when.some(stateName=>stateName===action.pending)) return true            \r\n            if(!action.when.some(stateName=>{\r\n                const nextStates = this.getState(stateName).next                \r\n                // 由于next参数可以是一个函数时，该函数仅在切换时被调用，因此在校验时只能先认为有效的\r\n                return Array.isArray(nextStates) ? nextStates.includes(action.pending as string) : true\r\n            })){\r\n                throw new StateMachineError(`状态动作<${name}>的pending参数无效,无法从<{${action.when.join()}}>切换到<${action.pending}>`)\r\n            }\r\n        }\r\n\r\n        // 判断能否切换到resolved/rejected/finally状态\r\n        // - 如果指定了有效的pending，则判断能否从pending切换到resolved/rejected/finally状态\r\n        // - 如果没有指定了有效的pending，则判断能否从when切换到resolved/rejected/finally状态\r\n        let fromStates = (this.isValid(action.pending) && typeof(action.pending)!==\"function\") ? [action.pending] : action.when\r\n        const endStates = [\"resolved\",\"rejected\",\"finally\"]\r\n        endStates.forEach((param)=>{\r\n            if(typeof(action[param])==\"string\"){             \r\n                if(Array.isArray(fromStates) && !fromStates.some((stateName:string | undefined)=>{\r\n                    const nextStates = this.getState(stateName).next                \r\n                    return Array.isArray(nextStates) ? nextStates.includes(action[param]) : true\r\n                })){\r\n                    throw new StateMachineError(`状态动作<${name}>的<${param}>参数无效,无法从${fromStates.join()}切换到${action[param]}`)\r\n                }\r\n            }\r\n        })\r\n\r\n    }\r\n    /**\r\n     * 创建动作执行函数\r\n     * @param action \r\n     * @returns \r\n     */\r\n    private _createActionExecutor(action:FlexStateAction){\r\n        return async function (this:any,...args:any[]) {       \r\n            this._assertRunning()           \r\n            if(this.isFinal()) throw new FinalStateError() \r\n            let result, oldStateName,finalState,pendingState,hasError:any = false,isPending=false\r\n            try{\r\n                oldStateName = this.current.name\r\n                // 1. 判断动作执行的前置状态: 仅在当前状态==when指定的状态或者当前状态=null时才允许执行\r\n                let whenState =flexStringArrayArgument(action.when,this.context,oldStateName)\r\n                // 如果当前状态是IDLE,则when参数不起作用。IDLE状态可以转换至任意状态\r\n                if(oldStateName!==IDLE_STATE.name && whenState.length>0 &&  !whenState.includes(oldStateName)){\r\n                    throw new TransitionError(`动作<${action.name}>只能在状态<${this.current.name}>下才允许执行,当前状态是<${whenState}>`)\r\n                }                    \r\n                // 2. 转换到pending状态: 如果指定了pending，则转换至该状态\r\n                pendingState = flexStringArgument(action.pending,this.context,result)\r\n                if(this.isValid(pendingState) && pendingState!==this.current.name){                    \r\n                    await this.transition(pendingState , ...args)   \r\n                    isPending = true                 \r\n                }                \r\n                // 3. 执行动作函数\r\n                result = await action.execute.apply(this.context,args)                          \r\n                // 4. 成功执行后的状态                    \r\n                finalState = flexStringArgument(action.resolved,this.context,result)\r\n                \r\n            }catch(e){\r\n                finalState = flexStringArgument(action.rejected,this.context,e)\r\n                hasError = e   \r\n                throw e\r\n            }finally{\r\n                // 如果执行成功：\r\n                //  - 当指定了resolved和finally参数时，则转换此到resolved和finally状态\r\n                //  - 如果没有指定resolved和finally参数,则会一直保持在pending参数指定的状态。\r\n                //  - 如果pending参数也没有指定，则执行动作不会导致状态改变\r\n                // 如果执行失败：\r\n                //  - 当指定了rejected参数时，则转换此到rejected状态\r\n                //  - 如果没有指定rejected参数，并且也指定了pending参数，则回退到pending之前的状态\r\n                //  - 如果没有指定rejected参数，也没有指定了pending参数，保持当前状态不变\r\n                // 如果指定了finally，则无论执行成功失败均切换至finally状态\r\n                finalState = flexStringArgument(action.finally,this.context,hasError || result) || finalState\r\n                if (this.isValid(finalState)) {\r\n                    try{\r\n                        // 切换到由resolved/rejected/finally三个参数决定的最终目标转换状态\r\n                        await this.transition(finalState, result)                        \r\n                    }catch(e){\r\n                        // 如果切换失败，则代表了整个执行出错，应该进行状态复原\r\n                        // 比如指定了resolved状态与当前状态是互悖的,就会导致动作执行成功，而无法转换到resolved状态\r\n                        // 例：当前状态是Disconnected，action.pending=\"Connecting\"，但是错误地配置了action.resolved=\"Disconnecting\"\r\n                        // 显然当执行Connect成功后应切换到Connected才是正确的，由于state.next已经约束了状态的切换\r\n                        // 也就是说执行成功，但是配置参数出错导致不能切换到正确的状态\r\n                        // 此种情况下有处理方法：\r\n                        //   - 首先应该在register(action)进行参数检查，并给出错误提示，避免无效的参数配置。\r\n                        //   - 但是如果action的resolved/rejected/finally三个参数是一个函数，则在注册时是无法检查参数的有效性的，直接切换必然后切换出错 \r\n                        //      直接抛出错误: 此时动作已经执行成功，但是状态已经是错误的了。\r\n                        //      由于再次重复执行动作可能是不可接受的，因为动作副作用可能已经产生                        \r\n                        //      因此，调用者应该自行处理副作用                         \r\n                        //      如果配置了启用自动错误状态，则状态机将切换到错误状态\r\n                        await this._transitionToError({to:finalState.name,error:e})   \r\n                    }                    \r\n                }else{\r\n                    // finalState是由resolved/rejected/finally三个参数决定的最终目标转换状态\r\n                    // 如果finalState无效，则说明resolved/rejected/finally三个参数均没有提供或者配置无效\r\n                    // 此时： \r\n                    //   - 如果曾经切换到pending状态并且执行出错，则需要恢复回退到原始状态\r\n                    //   - 如果未指定有效的pending参数或者无法切换至pending状态，保持原始状态不变\r\n                    if(isPending && hasError){\r\n                        this.#currentState = this.getState(oldStateName)\r\n                    }\r\n                }\r\n            }\r\n            return result\r\n        }\r\n    }\r\n    /**\r\n     * 注册状态动作\r\n     * \r\n     * action={\r\n     *      when         : [],                                  //当前状态=when中的一个时才允许执行\r\n     *      pending      : \"<状态名>\" || ()=>{},                // 执行前先切换到此状态\r\n     *      execute      : ()=>{},                              // 动作执行函数\r\n     *      resolved     : \"<状态名>\" || (result)=>{},          // 执行成功后的状态\r\n     *      rejected     : \"<状态名>\" || (error)=>{},           // 执行失败后的状态\r\n     *      finally      : \"<状态名>\" || (error,result)=>{},    // 无论成功或失败时的回调,也可以是一个状态，如果指定了此值,则resolved或rejected无效\r\n     *      timeout      : 0                                    // 执行动作的超时时间,默认不限\r\n     * }\r\n     * \r\n     * register(name,action)\r\n     * register(action)\r\n     * \r\n     * @param {Object} action           动作参数\r\n     */\r\n     register(action:FlexStateAction) {\r\n        this._normalizeAction(action)\r\n        if(!action.name) throw new TypeError(\"需要为动作指定一个名称\")\r\n        // 是否使用外部上下文\r\n        const useExternalContext = this !== this.context\r\n        // 包装动作函数\r\n        const fn = this._createActionExecutor(action)\r\n        this.#actions[action.name] = fn.bind(this.context)\r\n        // 在实现中为该动作生成一个[action.name]的实例方法\r\n        if(this.options.injectActionMethod) {\r\n            // 如果类上存在与动作名称相同的方法时，需要为动作指定一个别名，否则会给出警告\r\n            const actionName:string = (action.alias && action.alias.length>0) ? action.alias : action.name \r\n            // 只有当使用了外部上下文时注入冲突方法时才会给出警告          \r\n            if(useExternalContext && actionName in this.context) {\r\n                // 保存冲突方法的引用，当执行unregister(action)时可以恢复\r\n                if(!this.#conflictMethods) this.#conflictMethods=[this.context[actionName]]                  \r\n                this.#conflictMethods[actionName] = this.context[actionName]\r\n                console.warn(\"异步状态机注入的动作在实例上已经存在同名方法\")\r\n            }          \r\n            // 通过触发事件的方式来动作执行 \r\n            this.context[actionName] = (...args:any[])=>{\r\n                return new Promise((resolve, reject)=>{\r\n                    // 为什么要使用setTimout来执行动作?\r\n                    // 因为动作可能会在状态转换过程中被调用，使用setTimeout可以使动作执行从转换调用链中剥离\r\n                    setTimeout(async ()=>{\r\n                        try{                            \r\n                            resolve(await this.execute(actionName,...args))\r\n                        }catch(e){\r\n                            if(this.options.throwActionError) reject(e)                            \r\n                        }\r\n                    },0)\r\n                })\r\n            }        \r\n        } \r\n    }\r\n    /**\r\n     * 注销动作\r\n     * @param {*} name  动作名称\r\n     */\r\n    unregister(name: string){\r\n        if(name in this.#actions){            \r\n            if(this.#conflictMethods && (name in this.#conflictMethods)){\r\n                this[name] = this.#conflictMethods[name]\r\n            }   \r\n            delete this.#actions[name]         \r\n            delete this.context[name]\r\n        }\r\n    }\r\n    /**\r\n     * 取消正在进行的状态转换\r\n     */\r\n    async cancel() {\r\n        this.emit(\"transition/cancel\")\r\n    }\r\n    /**\r\n     * 强制转换状态机错误状态\r\n     * @param {*} params \r\n     */\r\n    private async _transitionToError(params:any){\r\n        this.#currentState = this.states.ERROR\r\n        await this._emitStateHookCallback(DoneStateEvent(\"ERROR\"),params)\r\n    }\r\n    /**\r\n     * 转换到指定状态\r\n     * \r\n     * 支持以下调用方式:\r\n     * - 指定状态名称\r\n     * transition(\"connect\",{a:1,b:2}) ==> onStateEnter(...{a:1,b:2})\r\n     * - transition(<返回状态的函数>,...)\r\n     * \r\n     * 如果next与current相同则直接返回\r\n     *\r\n     * @param {String} next   状态名称或函数，函数应该返回要切换到哪一个状态\r\n     * @param {*} params      传递给状态回调的参数\r\n     * \r\n     * @resturns  如果转换失败，则会触发错误\r\n     */\r\n    async transition(next:FlexStateArgs,params={}) {\r\n        this._assertRunning()   \r\n        // 如果正在转换中，则触发错误，不允许在转换状态中进行再次转换，这会导致状态混乱，因此触发错误\r\n        if (this.transitioning) throw new TransitioningError()     \r\n        // 如果状态已经处于最终状态,则不允许进行转换，除非重置状态机\r\n        if(this.isFinal()) throw new FinalStateError()\r\n        if(!this.isValid(next)) throw new InvalidStateError()\r\n        \r\n        this.#transitioning = true\r\n        // 1. 处理参数,参数将被用来传递给状态响应回调\r\n        const nextState = this.getState(next)           \r\n        // 如果当前状态与要转换的目标状态一致，则静默返回\r\n        if(this.current && nextState.name==this.current.name) return \r\n\r\n        let   isDone         = false                    // 转换成功标志\r\n        const beginTime      = Date.now()\r\n        const currentState   = this.current \r\n        const transitionInfo:FlexStateTransitionEventArguments = {\r\n            params,\r\n            from:currentState.name, \r\n            to: nextState.name\r\n        }\r\n\r\n        try{\r\n\r\n            // 2. 判断是否允许从当前状态切换到下一个状态\r\n            if (!this.canTransitionTo(nextState.name)) {\r\n                this._safeEmitEvent(FlexStateTransitionEvents.CANCEL, {event:\"CANCEL\",...transitionInfo})\r\n                throw new TransitionError(`不允许从状态<{${currentState.name}}>转换到状态<{${nextState.name}}>`)\r\n            }\r\n\r\n            // 2. 触发开始转换事件\r\n            this._safeEmitEvent(FlexStateTransitionEvents.BEGIN, {event:\"BEGIN\",...transitionInfo})\r\n\r\n            // 3. 进入next前，先离开当前状态： 当前状态可以通过触发Error来阻止状态切换\r\n            if(currentState.name!=IDLE_STATE.name){\r\n                const leaveResult = await this._emitStateHookCallback(LeaveStateEvent(currentState.name) , { ...transitionInfo })\r\n                if(leaveResult.error){     \r\n                    this._safeEmitEvent(FlexStateTransitionEvents.ERROR, {error:leaveResult.error,...transitionInfo})\r\n                    // 如果leave钩子抛出该错误，则说明\r\n                    if(leaveResult.error instanceof SideEffectTransitionError){\r\n                        await this._transitionToError({...transitionInfo,error:leaveResult.error})  // 转换到错误状态\r\n                    }\r\n                    throw leaveResult.error\r\n                }\r\n            }\r\n          \r\n            // 5. 触发下一个状态的enter回调\r\n            const enterResult = await this._emitStateHookCallback(EnterStateEvent(nextState.name), {...transitionInfo})\r\n            // 执行enter回调成功后\r\n            if(enterResult.error){\r\n                this._safeEmitEvent(FlexStateTransitionEvents.ERROR, {event:\"ERROR\",error:enterResult.error,...transitionInfo})\r\n                if(enterResult.error instanceof SideEffectTransitionError){// 不可消除的副作用\r\n                    await this._transitionToError({...transitionInfo,error:enterResult.error})  // 转换到错误状态\r\n                }else{// 可消除的副作用\r\n                    // 当无法进入nextState时，应该调用currentState的resume回调来恢复副作用\r\n                    const resumeResult = await this._emitStateHookCallback(ResumeStateEvent(currentState.name), {...transitionInfo,error:enterResult.error})\r\n                    // 如果无法恢复上下文，则应该转换到错误状态\r\n                    if(resumeResult.error){\r\n                        await this._transitionToError({...transitionInfo,error:resumeResult.error})  // 转换到错误状态\r\n                    }\r\n                }                \r\n                throw enterResult.error\r\n            }else{\r\n                this.#currentState = this.states[nextState.name]\r\n                isDone = true\r\n            }                  \r\n        }catch (e:any) {\r\n            this._safeEmitEvent(FlexStateTransitionEvents.ERROR, {event:\"ERROR\",error:e,...transitionInfo})\r\n            throw new TransitionError(e.message)\r\n        }finally{\r\n            this.#transitioning=false\r\n        }\r\n        // done事件不属于钩子事件，不能通过触发错误和返回false等方式中止转换过程\r\n        if(isDone) {\r\n            this._addHistory(this.current.name)\r\n            this._safeEmitEvent(DoneStateEvent(this.current.name),transitionInfo)\r\n            this._safeEmitEvent(FlexStateTransitionEvents.END, {event:\"END\",timeConsuming:Date.now()-beginTime,...transitionInfo})\r\n            if(this.isFinal()) this._safeEmitEvent(FlexStateEvents.FINAL)\r\n        }\r\n        return this\r\n    } \r\n    \r\n    private _addHistory(stateName:string){\r\n        if(this.options.history>0){\r\n            this.history.push([Date.now(),stateName]) \r\n            if(this.history.length>this.options.history) this.history.splice(0,1)\r\n        }\r\n    }\r\n    /**\r\n     * 触发事件并忽略事件处理函数的错误\r\n     */  \r\n     private _safeEmitEvent(event:string, ...args:any[]){\r\n        try{\r\n            this.emit(event,...args)\r\n        }catch(e){  }\r\n    }\r\n    /**\r\n     * 执行状态回调\r\n     * 触发事件\r\n     * \r\n     * 由于状态事件可能注册了多个回调，因此this.emitAsync返回的是[result,result,]\r\n     * \r\n     * 由于需要根据回调结果来进行后续的处理，因此需要一定的逻辑\r\n     * \r\n     * - 只要有一个返回false，就代表拒绝进入下一个状态\r\n     * - 只要有一个触发错误，就代表拒绝进入下一个状态\r\n     * \r\n     * \r\n     * @param {*} event\r\n     * @param {*} params 钩子参数\r\n     * @returns\r\n     */\r\n    private async _emitStateHookCallback(event:string, params:any) {\r\n        let eventResults,returnValue:Record<string,any> = {}\r\n        try{\r\n            // 触发onStateEnter等事件\r\n            eventResults = await this.emitAsync(event, params)\r\n            if (eventResults.some((r:any) => r as any === false)) {\r\n                returnValue = {error:new CancelledTransitionError()}\r\n            } else {\r\n                let errorIndex = eventResults.findIndex((r:any) => r instanceof Error )\r\n                if(errorIndex != -1) {\r\n                    returnValue = {error:eventResults[errorIndex]}\r\n                } \r\n            }\r\n            returnValue.result = eventResults        \r\n        }catch(e){\r\n            returnValue = {error:e}\r\n        }\r\n        return returnValue\r\n    }\r\n    /**\r\n     * 判断是否允许从fromState转换到toState\r\n     * \r\n     * 如果当前状态为空null,则只能转换到Initial\r\n     * \r\n     * canTransitionTo(to)          能否从当前状态转换到to状态\r\n     * canTransitionTo(from,to)     能否从from状态转换到to状态\r\n     * \r\n     * 如果from是一个数组，则只要其中一个状态允许转换即返回true\r\n     * \r\n     * @param fromState    状态名称或状态值 \r\n     * @param toState    状态名称或状态值\r\n     */\r\n     canTransitionTo(fromState:FlexStateArgs, toState?:FlexStateArgs):boolean \r\n     canTransitionTo(toState:FlexStateArgs):boolean\r\n     canTransitionTo():boolean{\r\n        let fromState:FlexState,toState:FlexState\r\n        // 将fromState和toState转换为完整的状态{...}\r\n        if (arguments.length === 1) {\r\n            fromState = this.current\r\n            toState = arguments[0]\r\n        } else if (arguments.length === 2) {\r\n            fromState = this.getState(arguments[0])\r\n            toState = arguments[1]\r\n        }else {\r\n            throw new TypeError(\"Error Param\")\r\n        }\r\n\r\n        // 目标状态\r\n        toState = this.getState(toState)\r\n\r\n        // 如果当前状态是IDLE, 则只能转换到Initial状态\r\n        if(fromState.name==IDLE_STATE.name && toState.name!=this.initial.name){\r\n            return false\r\n        }\r\n        // 如果已经是最终状态了，则不允许转换到任何状态\r\n        if(fromState.final){\r\n            return false\r\n        }\r\n        // next可以是一个函数，该函数(toState)\r\n        if (fromState && fromState.next) {\r\n            if(fromState.next===\"*\") return true\r\n            let nextStates  = fromState.next  \r\n            if(typeof (fromState.next) == \"function\") {\r\n                nextStates = fromState.next.call(this)\r\n            }\r\n            nextStates = Array.isArray(nextStates) ? nextStates : (typeof(nextStates) == \"string\" ? [nextStates] : [])\r\n            if(!nextStates.includes(\"ERROR\")) nextStates.push(\"ERROR\")            // 任何状态均可以转换至错误状态\r\n            // 如果next中包括*符号代表可以切换到任意状态\r\n            return ((nextStates.some(s=>s===\"*\")) || (nextStates.length === 1 && typeof(nextStates[0])=='string' && nextStates[0]===\"ERROR\") ? true : nextStates.includes(toState.name))\r\n        } else {\r\n            return true\r\n        }\r\n    }\r\n    /**\r\n     * 封装状态回调函数，使状态回调函数的执行支持：\r\n     *\r\n     *  1. 支持发送`${state.name}/cancel`事件取消执行\r\n     * \r\n     * \r\n     *  2. 支持超时/重试/去抖动/节流\r\n     *     可以在函数原型上定义timeout/retryCount/retryInterval/debounce/throttle参数\r\n     *     const fn = () =>{...};\r\n     *     fn.timeout = 0               // 指定超时 \r\n     *     也可以指在状态中指定\r\n     *     {\r\n     *          connecting:{\r\n     *             enter:async ()=>{...}\r\n                   enter:[\r\n                        async (result)=>{...},                        \r\n                        timeout,                     // 超时参数\r\n                   ],\r\n                   enter:fn\r\n     *          }   \r\n     *     }\r\n     *    \r\n     *   则当回调执行enter函数时，可以通过this.emit(\"transition/cancel\")来中止执行\r\n     * \r\n     *  2. 支持超时控制\r\n     * \r\n     *   也就是说如果执行超时，则代表失败，如当A->B时执行a.leave，如果执行a.leave超时，则代表失败\r\n     *   同样，如进入b.enter执行超时也代表失败 \r\n     * \r\n     * \r\n     */\r\n    private _makeStateHookCallback(fn:FlexStateTransitionHookExt) {\r\n        let [hookFn,runOptions] = Array.isArray(fn) ? fn : [fn,{timeout:0}];\r\n        if(!runOptions.timeout) runOptions.timeout = 0                 \r\n        let wrapperFn = timeoutWrapper(hookFn as any,{value:runOptions.timeout})\r\n        return (args:FlexStateTransitionHookArguments) => new Promise(async (resolve, reject) => {\r\n            // 取消操作\r\n            const cancel = () => reject(new CancelledTransitionError())       \r\n            // 订阅取消事件\r\n            this.once(FlexStateTransitionEvents.CANCEL, cancel)\r\n            let callCount = 1,retryInterval=0,hasError\r\n            // 供调用\r\n            args.retry = (ms=0) =>{retryInterval=ms;callCount++;throw new Error()}\r\n            args.retryCount = 0\r\n            while(callCount>0){\r\n                callCount--      \r\n                try{\r\n                    let result = await wrapperFn.call(this.context, args)  \r\n                    resolve(result)\r\n                }catch(e){\r\n                    hasError = e\r\n                }finally{\r\n                    args.retryCount++\r\n                }\r\n                if(callCount>0 && retryInterval>0) await delay(retryInterval)\r\n            }                \r\n            this.off(FlexStateTransitionEvents.CANCEL, cancel)  // 正常结束时，就应清除上面侦听once的cancel回调，也就是说不需要再侦听取消操作了            \r\n            if(hasError) reject(hasError)\r\n        })\r\n    } \r\n    /**\r\n     * 通过触发事件执行指定的动作\r\n     * \r\n     * .execute(\"<动作名称>\",...args)\r\n     * \r\n     * 一般会调用直接调用实例方法来执行动作\r\n     *  如 tcp.connect(....)\r\n     \r\n     *\r\n     * @param {*} name 动作名称\r\n     * @param args\r\n     */\r\n    async execute(name: string, ...args:any[]) {     \r\n        this._assertRunning()   \r\n        return await this.#actions[name].call(this,...args)\r\n    }\r\n\r\n    private _assertRunning(){\r\n        if(!this.#running) throw new NotRunningError()\r\n    }\r\n    /**\r\n     * 等待状态机进入指定状态\r\n     * \r\n     * @param {*} state   状态名称或状态值\r\n     */\r\n    async waitForState(state:FlexStateArgs){\r\n        const forState = this.getState(state)\r\n        if(this.current.name===forState.name || this.current.value===forState.value) return \r\n        return await this.waitFor(`${forState.name}/done`)        \r\n    }\r\n    /**\r\n     * 等待进入初始状态\r\n     * @returns \r\n     */\r\n    async waitForInitial(){\r\n        return this.waitForState(this.initial)\r\n    } \r\n}\r\n\r\n"]}